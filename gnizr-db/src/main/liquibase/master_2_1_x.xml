<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog logicalFilePath="classpath:/master_2_1_x.xml"
                   xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.0.xsd">

	<changeSet id="sp-user" author="vrebesbyrd@gmail.com">
		<sql splitStatements="false">
            --------------------------------------------------------------
            -- PROCEDURE: getUser(id)
            -- INPUT: id INTEGER
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION getUser(uid INTEGER) RETURNS SETOF "user" AS $c$
            BEGIN
              RETURN QUERY SELECT * FROM "user" as U WHERE U.id=uid;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: findUserUsername
            -- INPUT: username
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION findUserUsername(uname VARCHAR(45)) RETURNS SETOF "user" AS $c$
            BEGIN
              RETURN QUERY SELECT * FROM "user" as U WHERE U.username=uname;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: findAllUsers
            -- INPUT: NONE
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION findAllUsers() RETURNS SETOF "user" AS $c$
            BEGIN
              RETURN QUERY SELECT * FROM "user" as U WHERE U.username != "gnizr";
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: findUserUnamePwd
            -- INPUT: username
            --        password
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION findUserUnamePwd(uname VARCHAR(45), pwd VARCHAR(45)) RETURNS SETOF "user" AS $c$
            BEGIN
              RETURN QUERY SELECT * FROM "user" as U WHERE U.username=uname AND U.password=MD5(pwd);
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: deleteUser
            -- INPUT: uid
            -- OUTPUT NONE
            CREATE OR REPLACE FUNCTION deleteUser(uid INTEGER) RETURNS void AS $c$
            BEGIN
              DELETE FROM search_idx WHERE search_idx.bookmark_id in (SELECT id FROM bookmark WHERE bookmark.user_id = uid);
              DELETE FROM bookmark WHERE bookmark.user_id = uid;
              DELETE FROM "user" as U WHERE U.id=uid;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: createUser
            -- INPUT: username
            --        password,
            --        fullname,
            --        email,
            --        createdOn,
            --        status
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION createUser(IN uname VARCHAR(45), IN pwd VARCHAR(45),
                                                  IN fname VARCHAR(100),IN e_mail VARCHAR(50),
                                                  IN cOn timestamp with time zone,
                                                  IN st INTEGER) RETURNS integer AS $c$
            DECLARE
              newid integer;
            BEGIN
              INSERT INTO "user"(username,password,fullname,email,created_on,acct_status) VALUES (uname,MD5(pwd),fname,e_mail,cOn,st) RETURNING id INTO newid;
              RETURN newid;
            EXCEPTION WHEN unique_violation THEN
              RETURN -1;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: updateUser
            -- INPUT: username
            --        password
            --        fullname
            --        email
            --        createdOn
            --        status
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION updateUser(IN uid INTEGER,
                                                  IN uname VARCHAR(45),
                                                  IN pwd VARCHAR(45),
                                                  IN fname VARCHAR(100),
                                                  IN e_mail VARCHAR(50),
                                                  IN cOn timestamp with time zone,
                                                  IN st INTEGER) RETURNS void AS $c$

            BEGIN
              IF CHAR_LENGTH(password) > 0 THEN
                UPDATE "user" as U SET
                username = uname,
                password = MD5(pwd),
                fullname = fname,
                email = e_mail,
                created_on = cOn,
                acct_status = st WHERE U.id=uid;
              ELSE
                UPDATE "user" as U SET
                username = uname,
                fullname = fname,
                email = e_mail,
                created_on = cOn,
                acct_status = st WHERE U.id=uid;
              END IF;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: listUserStats
            -- INPUT: NONE
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION listUserStats() RETURNS SETOF "user" AS $c$
            BEGIN
              RETURN QUERY SELECT *,
              (SELECT count(*) FROM bookmark WHERE bookmark.user_id = U.id) as total_number_bookmark,
              (SELECT count(*) FROM user_tag_idx WHERE user_tag_idx.user_id = U.id) as total_number_tag
              FROM "user" as U ORDER BY U.username ASC;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: findTagGroupsOfUser
            -- INPUT: userId, minFreq, sortBy, orderFlag
            -- OUTPUT:
            --CREATE OR REPLACE FUNCTION findTagGroupsOfUser(IN userId INTEGER,
            --                                               IN minFreq INTEGER,
            --                                               IN sortBy INTEGER,
            --                                               IN orderFlag INTEGER) RETURNS refcursor AS $c$
            --DECLARE
            --  ref refcursor;
            --BEGIN
            --SET @userId = userId;
            --SET @minFreq = minFreq;
            --SET @qry = CONCAT("
            --(SELECT mem_tag.id AS mem_tag_id, mem_tag.tag AS mem_tag_tag, mem_tag.count AS mem_tag_count,
            --mem_tag_uti.id AS mem_tag_uti_id, mem_tag_uti.user_id AS mem_tag_uti_user_id,
            --mem_tag_uti.tag_id AS mem_tag_uti_tag_id, mem_tag_uti.count AS mem_tag_uti_count,
            --grp_tag.id AS grp_tag_id, grp_tag.tag AS grp_tag_tag, grp_tag.count AS grp_tag_count,
            --"user".id AS user_id, "user".username AS user_username, "user".password AS user_password,
            --"user".fullname AS user_fullname, "user".created_on AS user_created_on,
            --"user".email AS user_email, "user".acct_status AS user_acct_status
            --FROM tag as mem_tag, tag as grp_tag,
            --user_tag_idx as mem_tag_uti, user_tag_idx as grp_tag_uti,
            --tag_assertion, "user"
            --WHERE "user".id = ? AND
            --tag_assertion.user_id="user".id AND
            --tag_assertion.prpt_id=4 AND
            --tag_assertion.object_id = grp_tag_uti.id AND
            --tag_assertion.subject_id = mem_tag_uti.id AND
            --grp_tag_uti.tag_id = grp_tag.id AND
            --mem_tag_uti.tag_id = mem_tag.id AND
            --mem_tag_uti.count >= ?) UNION ");

            --SET @qry = CONCAT(@qry, "
            --(SELECT mem_tag.id, mem_tag.tag, mem_tag.count,
            --mem_tag_uti.id, mem_tag_uti.user_id, mem_tag_uti.tag_id, mem_tag_uti.count,
            --grp_tag.id, grp_tag.tag, grp_tag.count,
            --"user".id, "user".username,"user".password,"user".fullname,
            --"user".created_on,"user".email,"user".acct_status
            --FROM tag AS mem_tag, user_tag_idx as mem_tag_uti, "user",
            --(SELECT 0 AS id, '' AS tag, 0 AS count) AS grp_tag
            --WHERE "user".id = ? AND mem_tag_uti.user_id="user".id AND
            --mem_tag_uti.tag_id = mem_tag.id AND
            --mem_tag_uti.count >= ? AND
            --mem_tag_uti.id NOT IN
            --(SELECT tag_assertion.subject_id FROM tag_assertion
            --WHERE tag_assertion.user_id = "user".id AND tag_assertion.prpt_id=4)) ");

            ---- 1: sort alphabetically
            ---- 2: sort by usage freq
            --IF (sortBy = 1) THEN
            --SET @qry = CONCAT(@qry, " ORDER BY grp_tag_tag ASC, mem_tag_tag ");
            --ELSE
            --SET @qry = CONCAT(@qry, " ORDER BY grp_tag_tag ASC, mem_tag_count ");
            --END IF;

            --IF(orderFlag = 1) THEN
            --SET @qry = CONCAT(@qry, " DESC ");
            --ELSE
            --SET @qry = CONCAT(@qry, " ASC ");
            --END IF;

            --PREPARE STMT FROM @qry;
            --EXECUTE STMT USING @userId, @minFreq, @userId, @minFreq;
            --END;
            --$c$ LANGUAGE plpgsql;

        </sql>
	</changeSet>

    <changeSet id="sp-tagprpt" author="vrebesbyrd@gmail.com">
        <sql splitStatements="false">
            --------------------------------------------------------------
            -- PROCEDURE: getTagProperty
            -- INPUT: id INT
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION getTagProperty(tid integer) RETURNS SETOF tag_prpt AS $c$
            BEGIN
              RETURN QUERY SELECT * FROM tag_prpt as t WHERE t.id=tid;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: createTagProperty
            -- INPUT: name, ns_prefix, description, prpt_type, cardinaltiy
            -- OUTPUT: id
            CREATE OR REPLACE FUNCTION createTagProperty(IN n VARCHAR(45),
                                                         IN ns_pr VARCHAR(10),
                                                         IN descr VARCHAR(255),
                                                         IN prpt_t VARCHAR(255),
                                                         IN card integer) RETURNS integer AS $c$
            DECLARE
              newid integer;
            BEGIN
              INSERT INTO tag_prpt(name,ns_prefix,description,prpt_type,cardinality) VALUES (n,ns_pr,descr,prpt_t,card) RETURNING id INTO newid;
              RETURN newid;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: deleteTagProperty
            -- INPUT: id
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION deleteTagProperty(tid integer) RETURNS void AS $c$
            BEGIN
              DELETE FROM tag_prpt as tp WHERE tp.id=tid;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: updateTagProperty
            -- INPUT: id, name, ns_prefix, description, prpt_type, cardinaltiy
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION updateTagProperty(tid integer,
                                                         n VARCHAR(45),
                                                         ns_pr VARCHAR(10),
                                                         descr VARCHAR(255),
                                                         prpt_t VARCHAR(255),
                                                         card integer) RETURNS void AS $c$
            BEGIN
              UPDATE tag_prpt as tp SET
                name = n,
                ns_prefix = ns_pr,
                description = descr,
                prpt_type = prpt_t,
                cardinality = card
              WHERE tp.id=tid;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: listAllTagProperty
            -- INPUT: NONE
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION listAllTagProperty() RETURNS SETOF tag_prpt AS $c$
            BEGIN
              RETURN QUERY SELECT * FROM tag_prpt;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: getTagPropertyNSPrefixName
            -- INPUT: nsPrefix, name
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION getTagPropertyNSPrefixName(nsPr VARCHAR(10),
                                                                  n VARCHAR(45)) RETURNS SETOF tag_prpt AS $c$
            BEGIN
              RETURN QUERY SELECT * FROM tag_prpt WHERE tag_prpt.ns_prefix = nsPr AND tag_prpt.name = n;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: listTagPropertyOfType
            -- INPUT: prptType
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION listTagPropertyOfType(prptType VARCHAR(255)) RETURNS SETOF tag_prpt AS $c$
            BEGIN
              RETURN QUERY SELECT * FROM tag_prpt as tp WHERE tp.prpt_type = prptType;
            END;
            $c$ LANGUAGE plpgsql;
        </sql>
    </changeSet>

    <changeSet id="sp-gn-utils" author="vrebesbyrd@gmail.com">
        <sql splitStatements="false">
            --------------------------------------------------------------
            -- FUNCTION: bookmarkTags
            -- INPUT: bookmarkId
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION bookmarkTags(bookmarkId integer) RETURNS TEXT AS $c$
            DECLARE
              tags TEXT;
            BEGIN
              SELECT string_agg(DISTINCT t.tag, ' ') INTO tags
              FROM tag as t, bookmark_tag_idx as bti
              WHERE bti.bookmark_id = bookmarkId AND bti.count > 0 AND bti.tag_id = t.id
              GROUP BY t.tag
              ORDER BY t.tag;
              RETURN tags;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- FUNCTION: linkCount
            -- INPUT: linkId
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION linkCount(linkId integer) RETURNS integer AS $c$
            DECLARE
              ssize integer;
            BEGIN
              SELECT count(*) INTO ssize FROM bookmark as bmk WHERE bmk.link_id = linkId;
              RETURN ssize;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- FUNCTION: bookmarkInFolders
            -- INPUT: bookmarkId
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION bookmarkInFolders(bookmarkId integer) RETURNS TEXT AS $c$
            DECLARE
              fnames TEXT;
            BEGIN
              SELECT string_agg(DISTINCT f.folder_name, ',') INTO fnames
              FROM folder as f, bookmark_folder as bf
              WHERE bf.bookmark_id = bookmarkId AND bf.folder_id = f.id
              GROUP BY f.folder_name
              ORDER BY f.folder_name;
              RETURN fnames;
            END;
            $c$ LANGUAGE plpgsql;
        </sql>
    </changeSet>

    <changeSet id="sp-foruser" author="vrebesbyrd@gmail.com">
        <sql splitStatements="false">
            ---------------------------------------------------------------
            -- PROCEDURE: createForUser
            -- INPUT: bmid,
            --        tags,
            -- OUTPUT: id
            CREATE OR REPLACE FUNCTION createForUser(IN userId integer,
                                                     IN bmid integer,
                                                     IN msg TEXT,
                                                     IN createdOn timestamp with time zone) RETURNS integer AS $c$
            DECLARE
              newid integer;
            BEGIN
              SELECT fu.id INTO newid FROM for_user as fu WHERE fu.for_user_id = userId AND fu.bookmark_id = bmid;
              INSERT INTO for_user(for_user_id, bookmark_id, message, created_on) VALUES(userId, bmid, msg, createdOn) RETURNING id INTO newid;
              RETURN newid;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: deleteForUser
            -- INPUT: id
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION deleteForUser(fuid integer) RETURNS void AS $c$
            BEGIN
              DELETE FROM for_user as fu WHERE fu.id=fuid;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: getForUser
            -- INPUT: id
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION getForUser(IN fuid integer) RETURNS SETOF RECORD AS $c$
            BEGIN
              RETURN QUERY SELECT *, bookmarkTags(bmk.id) AS tags, bookmarkInFolders(bmk.id) AS folders, linkCount(lnk.id) AS count
              FROM for_user as fu, bookmark as bmk, link as lnk, user as fuser, user as buser
              WHERE fu.id=fuid AND fu.bookmark_id = bmk.id AND fu.for_user_id = fuser.id AND bmk.user_id = buser.id AND bmk.link_id = lnk.id;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: getForUserCount
            -- INPUT: id
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION getForUserCount(IN uid integer) RETURNS integer AS $c$
            DECLARE
              fu_count integer;
            BEGIN
              SELECT COUNT(*) INTO fu_count FROM for_user as fu WHERE fu.for_user_id=uid;
              RETURN fu_count;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: getForUserInTimeRangeCount
            -- INPUT: id, startTime, endTime
            -- OUTPUT: count INT
            CREATE OR REPLACE FUNCTION getForUserInTimeRangeCount(IN uid integer,
                                                        IN startTime timestamp with time zone,
                                                        IN endTime timestamp with time zone) RETURNS integer AS $c$
            DECLARE
              fu_count integer;
            BEGIN
              SELECT COUNT(*) INTO fu_count FROM for_user as fu WHERE fu.for_user_id=uid AND fu.created_on BETWEEN startTime AND endTime;
              RETURN fu_count;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: updateForUser
            CREATE OR REPLACE FUNCTION updateForUser (IN fuid integer,
                                            IN userId integer,
                                            IN bmid integer,
                                            IN msg TEXT,
                                            IN createdOn timestamp with time zone) RETURNS void AS $c$
            BEGIN
              UPDATE for_user as fu SET
                for_user_id=userId,
                bookmark_id=bmid,
                message=msg,
                created_on=createdOn
              WHERE fu.id=fuid;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: hasForUser
            -- INPUT: offset,
            --        count
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION hasForUser(IN bmid integer, IN userId integer) RETURNS integer AS $c$
            DECLARE
              fu_count integer;
            BEGIN
              SELECT COUNT(*) INTO fu_count FROM for_user as fu WHERE fu.for_user_id=userId AND fu.bookmark_id=bmid;
              RETURN fu_count;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: pageForUser
            -- INPUT: offset,
            --        count
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION pageForUser(IN userId integer, IN off integer, IN count integer) RETURNS SETOF RECORD AS $c$
            BEGIN
              RETURN QUERY SELECT *, bookmarkTags(bmk.id) AS tags, bookmarkInFolders(bmk.id) AS folders, linkCount(lnk.id) AS count
              FROM for_user as fu, bookmark as bmk, link as lnk, user as fuser, user as buser
              WHERE bmk.id=fu.bookmark_id AND fu.for_user_id=userId AND fu.for_user_id=fuser.id AND bmk.user_id=buser.id AND bmk.link_id=lnk.id
              ORDER BY fu.created_on DESC LIMIT count OFFSET off;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: listForUserFromBookmark
            -- INPUT: id
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION listForUserFromBookmark(bmid integer) RETURNS SETOF RECORD AS $c$
            BEGIN
              RETURN QUERY SELECT *, bookmarkTags(bmk.id) AS tags, bookmarkInFolders(bmk.id) AS folders, linkCount(lnk.id) AS count
              FROM for_user as fu, bookmark as bmk, link as lnk, user as fuser, user as buser
              WHERE fu.bookmark_id=bmid AND fu.bookmark_id=bmk.id AND fu.for_user_id=fuser.id AND bmk.user_id=buser.id AND bmk.link_id=lnk.id;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: pageForUserInTimeRange
            -- INPUT: userId,
            --        startTime,
            --        endTime,
            --        offset,
            --        count
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION pageForUserInTimeRange(userId integer,
                                                              startTime timestamp with time zone,
                                                              endTime timestamp with time zone,
                                                              off integer,
                                                              count integer) RETURNS SETOF RECORD AS $c$
            BEGIN
              RETURN QUERY SELECT *, bookmarkTags(bmk.id) AS tags, bookmarkInFolders(bmk.id) AS folders, linkCount(lnk.id) AS count
              FROM for_user as fu, bookmark as bmk, link as lnk, user as fuser, user as buser
              WHERE fu.for_user_id=userId AND fu.created_on BETWEEN startTime AND endTime AND bmk.id = fu.bookmark_id AND bmk.link_id = lnk.id AND bmk.user_id = buser.id AND fu.for_user_id = fuser.id
              ORDER BY fu.created_on DESC LIMIT count OFFSET off;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------------
            -- PROCEDURE: pageForUserBySenderId
            -- INPUT: userId, senderId, offset, count
            -- OUTPUT: totalCount
            CREATE OR REPLACE FUNCTION pageForUserBySenderId(IN userId integer,
                                                             IN senderId integer,
                                                             IN off integer,
                                                             IN cnt integer) RETURNS integer AS $c$
            DECLARE
              totalCount integer;
            BEGIN
              SELECT COUNT(*) INTO totalCount
              FROM for_user as fu, bookmark as bmk, user as fuser, user as buser, link as lnk
              WHERE fu.id IN (SELECT fuu.id FROM for_user as fuu, bookmark as bmkk WHERE fuu.for_user_id = userId AND fuu.bookmark_id = bmkk.id AND bmkk.user_id = senderId)
                AND fu.for_user_id = fuser.id AND fu.bookmark_id = bmk.id AND bmk.link_id = lnk.id AND bmk.user_id = buser.id;
              RETURN totalCount;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------------
            -- PROCEDURE: deleteForUserById
            -- INPUT: userId, id
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION deleteForUserById(IN userId integer, IN fuid integer) RETURNS void AS $c$
            BEGIN
              DELETE FROM for_user as fu WHERE fu.for_user_id = userId AND fu.id = fuid;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------------
            -- PROCEDURE: deleteAllForUser
            -- INPUT: userId, id
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION deleteAllForUser(IN userId integer) RETURNS void AS $c$
            BEGIN
              DELETE FROM for_user as fu WHERE fu.for_user_id = userId;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------------
            -- PROCEDURE: listForUserSenders
            -- INPUT: forUserId
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION listForUserSenders(IN fuid integer) RETURNS SETOF "user" AS $c$
            BEGIN
              RETURN QUERY SELECT * FROM "user" as U WHERE U.id IN
              (SELECT DISTINCT bmk.user_id FROM bookmark as bmk, for_user as fu WHERE fu.for_user_id = fuid AND fu.bookmark_id = bmk.id);
            END;
            $c$ LANGUAGE plpgsql;
        </sql>
    </changeSet>

</databaseChangeLog>