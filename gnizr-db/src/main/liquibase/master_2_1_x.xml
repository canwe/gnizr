<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog logicalFilePath="classpath:/master_2_1_x.xml"
                   xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.0.xsd">

	<changeSet id="sp-user" author="vrebesbyrd@gmail.com">
		<sql splitStatements="false">
            --------------------------------------------------------------
            -- PROCEDURE: getUser(id)
            -- INPUT: id INTEGER
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION getUser(uid INTEGER) RETURNS refcursor AS $c$
            DECLARE
              ref refcursor;
            BEGIN
              OPEN ref FOR SELECT * FROM "user" as U WHERE U.id=uid;
              RETURN ref;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: findUserUsername
            -- INPUT: username
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION findUserUsername(uname VARCHAR(45)) RETURNS refcursor AS $c$
            DECLARE
              ref refcursor;
            BEGIN
              OPEN ref FOR SELECT * FROM "user" as U WHERE U.username=uname;
              RETURN ref;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: findAllUsers
            -- INPUT: NONE
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION findAllUsers() RETURNS refcursor AS $c$
            DECLARE
              ref refcursor;
            BEGIN
              OPEN ref FOR SELECT * FROM "user" as U WHERE U.username != "gnizr";
              RETURN ref;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: findUserUnamePwd
            -- INPUT: username
            --        password
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION findUserUnamePwd(uname VARCHAR(45), pwd VARCHAR(45)) RETURNS refcursor AS $c$
            DECLARE
              ref refcursor;
            BEGIN
              OPEN ref FOR SELECT * FROM "user" as U WHERE U.username=uname AND U.password=MD5(pwd);
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: deleteUser
            -- INPUT: uid
            -- OUTPUT NONE
            CREATE OR REPLACE FUNCTION deleteUser(uid INTEGER) RETURNS void AS $c$
            BEGIN
              DELETE FROM search_idx
              WHERE search_idx.bookmark_id in (SELECT id FROM bookmark WHERE bookmark.user_id = uid);
              DELETE FROM bookmark
              WHERE bookmark.user_id = uid;
              DELETE FROM "user" as U
              WHERE U.id=uid;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: createUser
            -- INPUT: username
            --        password,
            --        fullname,
            --        email,
            --        createdOn,
            --        status
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION createUser(IN uname VARCHAR(45), IN pwd VARCHAR(45),
                                                  IN fname VARCHAR(100),IN e_mail VARCHAR(50),
                                                  IN cOn timestamp with time zone,
                                                  IN st INTEGER) RETURNS integer AS $c$
            DECLARE
              newid integer;
            BEGIN
              INSERT INTO "user"(username,password,fullname,email,created_on,acct_status) VALUES (uname,MD5(pwd),fname,e_mail,cOn,st) RETURNING id INTO newid;
              RETURN newid;
            EXCEPTION WHEN unique_violation THEN
              RETURN -1;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: updateUser
            -- INPUT: username
            --        password
            --        fullname
            --        email
            --        createdOn
            --        status
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION updateUser(IN uid INTEGER,
                                                  IN uname VARCHAR(45),
                                                  IN pwd VARCHAR(45),
                                                  IN fname VARCHAR(100),
                                                  IN e_mail VARCHAR(50),
                                                  IN cOn timestamp with time zone,
                                                  IN st INTEGER) RETURNS void AS $c$

            BEGIN
              IF CHAR_LENGTH(password) > 0 THEN
                UPDATE "user" as U SET
                U.username = uname,
                U.password = MD5(pwd),
                U.fullname = fname,
                U.email = e_mail,
                U.created_on = cOn,
                U.acct_status = st WHERE U.id=uid;
              ELSE
                UPDATE "user" as U SET
                U.username = uname,
                U.fullname = fname,
                U.email = e_mail,
                U.created_on = cOn,
                U.acct_status = st WHERE U.id=id;
              END IF;
            END;
            $c$ LANGUAGE plpgsql;

            --------------------------------------------------------------
            -- PROCEDURE: listUserStats
            -- INPUT: NONE
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION listUserStats() RETURNS refcursor AS $c$
            DECLARE
              ref refcursor;
            BEGIN
              OPEN ref FOR SELECT *,
              (SELECT count(*) FROM bookmark WHERE bookmark.user_id = U.id) as total_number_bookmark,
              (SELECT count(*) FROM user_tag_idx WHERE user_tag_idx.user_id = U.id) as total_number_tag
              FROM "user" as U ORDER BY U.username ASC;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: findTagGroupsOfUser
            -- INPUT: userId, minFreq, sortBy, orderFlag
            -- OUTPUT:
            --CREATE OR REPLACE FUNCTION findTagGroupsOfUser(IN userId INTEGER,
            --                                               IN minFreq INTEGER,
            --                                               IN sortBy INTEGER,
            --                                               IN orderFlag INTEGER) RETURNS refcursor AS $c$
            --DECLARE
            --  ref refcursor;
            --BEGIN
            --SET @userId = userId;
            --SET @minFreq = minFreq;
            --SET @qry = CONCAT("
            --(SELECT mem_tag.id AS mem_tag_id, mem_tag.tag AS mem_tag_tag, mem_tag.count AS mem_tag_count,
            --mem_tag_uti.id AS mem_tag_uti_id, mem_tag_uti.user_id AS mem_tag_uti_user_id,
            --mem_tag_uti.tag_id AS mem_tag_uti_tag_id, mem_tag_uti.count AS mem_tag_uti_count,
            --grp_tag.id AS grp_tag_id, grp_tag.tag AS grp_tag_tag, grp_tag.count AS grp_tag_count,
            --"user".id AS user_id, "user".username AS user_username, "user".password AS user_password,
            --"user".fullname AS user_fullname, "user".created_on AS user_created_on,
            --"user".email AS user_email, "user".acct_status AS user_acct_status
            --FROM tag as mem_tag, tag as grp_tag,
            --user_tag_idx as mem_tag_uti, user_tag_idx as grp_tag_uti,
            --tag_assertion, "user"
            --WHERE "user".id = ? AND
            --tag_assertion.user_id="user".id AND
            --tag_assertion.prpt_id=4 AND
            --tag_assertion.object_id = grp_tag_uti.id AND
            --tag_assertion.subject_id = mem_tag_uti.id AND
            --grp_tag_uti.tag_id = grp_tag.id AND
            --mem_tag_uti.tag_id = mem_tag.id AND
            --mem_tag_uti.count >= ?) UNION ");

            --SET @qry = CONCAT(@qry, "
            --(SELECT mem_tag.id, mem_tag.tag, mem_tag.count,
            --mem_tag_uti.id, mem_tag_uti.user_id, mem_tag_uti.tag_id, mem_tag_uti.count,
            --grp_tag.id, grp_tag.tag, grp_tag.count,
            --"user".id, "user".username,"user".password,"user".fullname,
            --"user".created_on,"user".email,"user".acct_status
            --FROM tag AS mem_tag, user_tag_idx as mem_tag_uti, "user",
            --(SELECT 0 AS id, '' AS tag, 0 AS count) AS grp_tag
            --WHERE "user".id = ? AND mem_tag_uti.user_id="user".id AND
            --mem_tag_uti.tag_id = mem_tag.id AND
            --mem_tag_uti.count >= ? AND
            --mem_tag_uti.id NOT IN
            --(SELECT tag_assertion.subject_id FROM tag_assertion
            --WHERE tag_assertion.user_id = "user".id AND tag_assertion.prpt_id=4)) ");

            ---- 1: sort alphabetically
            ---- 2: sort by usage freq
            --IF (sortBy = 1) THEN
            --SET @qry = CONCAT(@qry, " ORDER BY grp_tag_tag ASC, mem_tag_tag ");
            --ELSE
            --SET @qry = CONCAT(@qry, " ORDER BY grp_tag_tag ASC, mem_tag_count ");
            --END IF;

            --IF(orderFlag = 1) THEN
            --SET @qry = CONCAT(@qry, " DESC ");
            --ELSE
            --SET @qry = CONCAT(@qry, " ASC ");
            --END IF;

            --PREPARE STMT FROM @qry;
            --EXECUTE STMT USING @userId, @minFreq, @userId, @minFreq;
            --END;
            --$c$ LANGUAGE plpgsql;

        </sql>
	</changeSet>

</databaseChangeLog>