<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog logicalFilePath="classpath:/master_2_1_sp_folder.xml"
                   xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.0.xsd">

    <changeSet id="sp-folder" author="vrebesbyrd@gmail.com">
        <sql splitStatements="false">
            <![CDATA[
            ---------------------------------------------------------------
            -- PROCEDURE: createFolder
            CREATE OR REPLACE FUNCTION createFolder(IN userId integer, IN fname VARCHAR(45), IN descr TEXT, IN lu timestamp with time zone) RETURNS integer AS $c$
            DECLARE
              newid integer;
            BEGIN
              INSERT INTO folder(owner_id,folder_name,description,last_updated) VALUES (userId,fname,descr,lu) RETURNING id INTO newid;
              RETURN newid;
            EXCEPTION WHEN unique_violation THEN
              SELECT f.id INTO newid FROM folder as f WHERE f.owner_id = userId AND f.folder_name = fname;
              RETURN newid;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: updateFolder
            CREATE OR REPLACE FUNCTION updateFolder(IN fid integer, IN ownerId integer, IN fName VARCHAR(45), IN descr TEXT, IN lu timestamp with time zone) RETURNS void AS $c$
            BEGIN
              UPDATE folder as f SET
                owner_id = ownerId,
                folder_name = fName,
                description = descr,
                last_updated = lu
              WHERE f.id = fid;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: deleteFolderByOwnerIdFolderName
            CREATE OR REPLACE FUNCTION deleteFolderByOwnerIdFolderName (IN ownerId integer, IN folderName VARCHAR(45)) RETURNS void AS $c$
            BEGIN
              DELETE FROM bookmark_folder as bf WHERE bf.folder_id in (SELECT f.id FROM folder as f WHERE f.owner_id = ownerId AND f.folder_name = folderName);
              DELETE FROM folder as f WHERE f.owner_id = ownerId AND f.folder_name = folderName;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: getFolderById
            CREATE OR REPLACE FUNCTION getFolderById (IN fid integer) RETURNS SETOF RECORD AS $c$
            BEGIN
              RETURN QUERY SELECT f.*, own.*, folderSize(f.id) as folder_size
              FROM "user" AS own, folder as f
              WHERE f.id = fid AND f.owner_id = own.id;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: getFolderByOwnerIdFolderName
            CREATE OR REPLACE FUNCTION getFolderByOwnerIdFolderName (IN ownerId integer, IN folderName VARCHAR(45)) RETURNS SETOF RECORD AS $c$
            BEGIN
              RETURN QUERY SELECT f.*, own.*, folderSize(f.id) as folder_size
              FROM "user" AS own, folder as f
              WHERE f.owner_id = ownerId AND f.owner_id = own.id AND f.folder_name = folderName;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: pageFoldersByOwnerId
            CREATE OR REPLACE FUNCTION pageFoldersByOwnerId (IN ownerId integer, IN off integer, IN cnt integer) RETURNS SETOF RECORD AS $c$
            DECLARE
              totalCount integer;
            BEGIN
              SELECT COUNT(*) into totalCount
              FROM folder as f, "user" AS own
              WHERE f.owner_id = ownerId AND f.owner_id = own.id;

              RETURN QUERY SELECT f.*, own.*, folderSize(f.id) as folder_size, totalCount
              FROM folder as f, "user" AS own
              WHERE f.owner_id = ownerId AND f.owner_id = own.id
              ORDER BY f.folder_name
              LIMIT cnt OFFSET off;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: pageBookmarksByFolderId
            -- INPUT: folderId, offset, count
            -- OUTPUT: totalCount
            CREATE OR REPLACE FUNCTION pageBookmarksByFolderId (IN folderId integer, IN off integer, IN lim integer, IN sortBy integer, IN orderFlag integer) RETURNS SETOF RECORD AS $c$
            DECLARE
              totalCount integer;
            BEGIN
              SELECT COUNT(*) into totalCount
              FROM link as L, "user" as U, bookmark as B, bookmark_folder as BF
              WHERE BF.folder_id = folderId AND BF.bookmark_id = B.id AND B.link_id = L.id AND B.user_id = U.id;

              RETURN QUERY SELECT B.*, U.*, L.*, bookmarkTags(B.id) AS tags, bookmarkInFolders(B.id) AS folders, linkCount(L.id) AS cnt, totalCount
              FROM link as L, "user" as U, bookmark as B, bookmark_folder as BF
              WHERE BF.folder_id = folderId AND BF.bookmark_id = B.id AND B.link_id = L.id AND B.user_id = U.id
              ORDER BY B.created_on
              LIMIT lim OFFSET off;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: pageBookmarksByFolderIdTagId
            -- INPUT: folderId, offset, count, sortBy, orderFlag
            -- OUTPUT: totalCount
            CREATE OR REPLACE FUNCTION pageBookmarksByFolderIdTagId(IN folderId integer, IN tagId integer, IN off integer, IN lim integer, IN sortBy integer, IN orderFlag integer) RETURNS SETOF RECORD AS $c$
            DECLARE
              totalCount integer;
            BEGIN
              SELECT COUNT(*) into totalCount
              FROM link as l, user as u, bookmark as b, bookmark_folder as bf, bookmark_tag_idx as bti
              WHERE bf.folder_id = folderId AND bf.bookmark_id = b.id AND bti.tag_id = tagId AND bti."count" > 0 AND bti.bookmark_id = b.id AND b.link_id = l.id AND b.user_id = u.id;

              RETURN QUERY SELECT B.*, BF.*, BTI.*, U.*, L.*,  bookmarkTags(bookmark.id) AS tags, bookmarkInFolders(bookmark.id) AS folders, linkCount(link.id) AS count, totalCount
              FROM link as L, user as U, bookmark as B, bookmark_folder as BF, bookmark_tag_idx as BTI
              WHERE BF.folder_id = folderId AND BF.bookmark_id = B.id AND BTI.tag_id = tagId AND BTI."count" > 0 AND BTI.bookmark_id = B.id AND B.link_id = L.id AND B.user_id = U.id
              ORDER BY
                CASE WHEN sortBy = 1 AND orderFlag = 1 THEN @>B.createdOn
                     WHEN sortBy = 1 AND orderFlag = 2 THEN @<B.createdOn
                     WHEN sortBy = 2 AND orderFlag = 1 THEN @>B.last_updated
                     WHEN sortBy = 2 AND orderFlag = 2 THEN @<B.last_updated
                     WHEN sortBy != 1 AND sortBy != 2 AND orderFlag = 2 THEN @<BF.last_updated
                     WHEN sortBy != 1 AND sortBy != 2 AND orderFlag = 1 THEN @>BF.last_updated
                     ELSE BF.last_updated
                END
              LIMIT lim OFFSET off;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: addBookmarkToFolder
            -- INPUT: folderId,bookmarkId,lastUpdated
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION addBookmarkToFolder(IN folderId integer, IN bookmarkId integer, IN lastUpdated timestamp with time zone) RETURNS void AS $c$
            BEGIN
              INSERT INTO bookmark_folder(folder_id,bookmark_id,last_updated) VALUES (folderId,bookmarkId,lastUpdated);

              --initialize records that don't exist in the table.
              INSERT INTO folder_tag_idx(folder_id,tag_id,"count")
              SELECT folderId, bti.tag_id, 0 FROM bookmark_tag_idx as bti
              WHERE bti.bookmark_id = bookmarkId AND bti.tag_id NOT IN
              (SELECT ft.tag_id FROM folder_tag_idx as ft WHERE ft.folder_id = folderId);

              UPDATE folder_tag_idx SET "count" = "count" + 1
              WHERE folder_id = folderId AND tag_id IN
              (SELECT bti.tag_id FROM bookmark_tag_idx as bti WHERE bti.bookmark_id = bookmarkId AND bti."count" > 0);
            EXCEPTION WHEN unique_violation THEN
              RETURN;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: removeBookmarkFromFolder
            -- INPUT: folderId, bookmarkId
            -- OUTPUT: NONE
            CREATE OR REPLACE FUNCTION removeBookmarkFromFolder(IN folderId integer, IN bookmarkId integer) RETURNS void AS $c$
            DECLARE
              rowCnt integer;
            BEGIN
              DELETE FROM bookmark_folder as bf WHERE bf.folder_id = folderId AND bf.bookmark_id = bookmarkId;

              GET DIAGNOSTICS rowCnt = ROW_COUNT;
              IF (rowCnt > 0) THEN
                UPDATE folder_tag_idx SET
                  count = count - 1
                WHERE folder_id = folderId AND count > 0
                  AND tag_id IN (SELECT bti.tag_id FROM bookmark_tag_idx as bti WHERE bti.bookmark_id = bookmarkId AND bti.count > 0);
              END IF;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: removeAllBookmarksFromFolder
            CREATE OR REPLACE FUNCTION removeAllBookmarksFromFolder(IN folderId integer) RETURNS void AS $c$
            BEGIN
              DELETE FROM folder_tag_idx as fti WHERE fti.folder_id = folderId;
              DELETE FROM bookmark_folder as bf WHERE bf.folder_id = folderId;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: pageContainedInFolders
            -- INPUT: bookmarkId,offset,count
            -- OUTPUT: totalCount
            --CREATE OR REPLACE FUNCTION pageContainedInFolders(IN bookmarkId integer, IN off integer, IN cnt integer, OUT totalCount integer)
            --BEGIN
            --  SET @offset = offset;
            --  SET @count = count;
            --  SET @bookmarkId = bookmarkId;
            --  PREPARE STMT FROM "
            --  SELECT SQL_CALC_FOUND_ROWS *, folderSize(folder.id) as folder_size
            --  FROM folder, user as own
            --  WHERE folder.id IN
            --  (SELECT bookmark_folder.folder_id
            --  FROM bookmark_folder WHERE
            --  bookmark_folder.bookmark_id = ?) AND
            --  folder.owner_id = own.id
            --  ORDER BY folder.folder_name
            --  LIMIT ?, ?;
            --  ";
            --  EXECUTE STMT USING @bookmarkId, @offset, @count;
            --  SELECT FOUND_ROWS() INTO totalCount;
            --END;
            --$c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- FUNCTION: folderSize
            CREATE OR REPLACE FUNCTION folderSize(folderId integer) RETURNS integer AS $c$
            DECLARE
              ssize integer;
            BEGIN
              SELECT count(*) INTO ssize
              FROM bookmark_folder as bf
              WHERE bf.folder_id = folderId;
              RETURN ssize;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: hasFolderTag
            CREATE OR REPLACE FUNCTION hasFolderTag(IN folderId integer, IN tagId integer) RETURNS SETOF folder_tag_idx AS $c$
            BEGIN
              RETURN QUERY SELECT *
              FROM folder_tag_idx as fti
              WHERE fti.folder_id = folderId AND fti.tag_id = tagId;
            END;
            $c$ LANGUAGE plpgsql;

            ---------------------------------------------------------------
            -- PROCEDURE: findAllTagsInFolder
            -- INPUT: folderId, sortBy, minFreq, orderFlag integer
            CREATE OR REPLACE FUNCTION findAllTagsInFolder(IN folderId integer, IN minFreq integer, IN sortBy integer, IN orderFlag integer) RETURNS SETOF RECORD AS $c$
            BEGIN
              RETURN QUERY SELECT t.*, fti.* FROM tag as t, folder_tag_idx as fti
              WHERE fti.folder_id = folderId AND fti.tag_id = t.id AND fti."count" >= minFreq;
            END;
            $c$ LANGUAGE plpgsql;
            -- ORDER BY
                -- CASE
                     -- TODO when sortBy = 1 AND orderFlag = 1 then @>t.tag
                     -- TODO when sortBy = 1 AND orderFlag != 1 then @<t.tag
                     -- when sortBy != 1 AND orderFlag = 1 then @>fti."count"
                     -- when sortBy != 1 AND orderFlag != 1 then @<fti."count"
                     -- else t.tag
                -- END;

            ---------------------------------------------------------------
            -- PROCEDURE: findTagGroupsInFolder
            -- INPUT: folderId, minFreq, sortBy, orderFlag
            -- OUTPUT:
            --CREATE OR REPLACE FUNCTION findTagGroupsInFolder(IN folderId integer,
            --IN minFreq integer,
            --IN sortBy integer,
            --IN orderFlag integer)
            --BEGIN
            --SET @folderId = folderId;
            --SET @minFreq = minFreq;
            --SET @qry = CONCAT("
            --(SELECT mem_tag.id AS mem_tag_id, mem_tag.tag AS mem_tag_tag, mem_tag.count AS mem_tag_count,
            --grp_tag.id AS grp_tag_id, grp_tag.tag AS grp_tag_tag, grp_tag.count AS grp_tag_count,
            --fti.folder_id AS fti_folder_id, fti.tag_id AS fti_tag_id, fti.count AS fti_count
            --FROM tag as mem_tag, tag as grp_tag,
            --user_tag_idx as mem_tag_uti,
            --user_tag_idx as grp_tag_uti,
            --tag_assertion,
            --folder_tag_idx AS fti
            --WHERE tag_assertion.user_id=(SELECT folder.owner_id FROM folder where folder.id=?) AND
            --tag_assertion.prpt_id=4 AND
            --tag_assertion.object_id = grp_tag_uti.id AND
            --tag_assertion.subject_id = mem_tag_uti.id AND
            --grp_tag_uti.tag_id = grp_tag.id AND
            --mem_tag_uti.tag_id = mem_tag.id AND
            --fti.folder_id = ? AND
            --fti.tag_id = mem_tag.id AND
            --fti.count >= ? ) ");

            --SET @qry = CONCAT(@qry, " UNION ");

            --SET @qry = CONCAT(@qry, "
            --(SELECT mem_tag.id, mem_tag.tag, mem_tag.count,
            --grp_tag.id, grp_tag.tag, grp_tag.count,
            --fti.folder_id, fti.tag_id, fti.count
            --FROM tag AS mem_tag,
            --(SELECT 0 AS id, '' AS tag, 0 AS count) AS grp_tag,
            --folder_tag_idx AS fti
            --WHERE fti.folder_id = ? AND
            --fti.tag_id=mem_tag.id AND
            --fti.count >= ? AND
            --mem_tag.id NOT IN (SELECT user_tag_idx.tag_id
            --FROM user_tag_idx, tag_assertion, folder
            --WHERE folder.id=fti.folder_id AND
            --folder.owner_id = tag_assertion.user_id AND
            --tag_assertion.subject_id = user_tag_idx.id AND
            --tag_assertion.prpt_id = 4)) ");

            --- 1: sort alphabetically
            --- 2: sort by usage freq
            --IF (sortBy = 1) THEN
            --SET @qry = CONCAT(@qry, " ORDER BY grp_tag_tag ASC, mem_tag_tag ");
            --ELSE
            --SET @qry = CONCAT(@qry, " ORDER BY grp_tag_tag ASC, fti_count ");
            --END IF;

            --IF(orderFlag = 1) THEN
            --SET @qry = CONCAT(@qry, " DESC ");
            --ELSE
            --SET @qry = CONCAT(@qry, " ASC ");
            --END IF;
            --PREPARE STMT FROM @qry;
            --EXECUTE STMT USING @folderId, @folderId, @minFreq, @folderId, @minFreq;
            --END//

            ---------------------------------------------------------------
            -- PROCEDURE: findTagsUsedInAnyFolder
            --CREATE OR REPLACE FUNCTION findTagsUsedInAnyFolder(IN userId integer, IN sortBy integer, IN minFreq integer)
            --BEGIN
            --  SELECT *, SUM(fti.count) as totalCount
            --  FROM tag as t, folder_tag_idx as fti
            --  WHERE fti.folder_id IN (SELECT fld.id FROM folder as fld WHERE fld.owner_id = userId)
            --    AND fti.tag_id = t.id
            --  GROUP BY fti.tag_id;
            --END;
            --$c$ LANGUAGE plpgsql;
            ]]>
        </sql>
    </changeSet>

</databaseChangeLog>